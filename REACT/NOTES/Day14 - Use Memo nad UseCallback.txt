ğŸ” Why useMemo and useCallback exist

In React:

Every state change â†’ component re-renders

Every re-render â†’

functions are recreated

calculations re-run

child components may re-render unnecessarily

ğŸ‘‰ These hooks optimize performance, not logic.

ğŸ§  useMemo â€” Memoizing a VALUE
What it does

useMemo stores (caches) the result of a calculation
React will reuse the cached value until dependencies change.

Syntax
const memoizedValue = useMemo(() => {
  return computeSomething();
}, [dependencies]);

ğŸ”¬ What happens internally

First render â†’ function runs â†’ value stored

Next render:

dependencies same â†’ return stored value

dependencies changed â†’ recompute

âœ… When to use useMemo

âœ” Heavy calculations
âœ” Filtering large arrays
âœ” Sorting data
âœ” Derived state

âŒ Simple calculations (a + b)
âŒ Premature optimization

ğŸ§ª Example 1: Expensive calculation
import { useState, useMemo } from "react";

function slowFunction(num) {
  console.log("Heavy calculation...");
  for (let i = 0; i < 1e9; i++) {}
  return num * 2;
}

export default function App() {
  const [number, setNumber] = useState(2);
  const [count, setCount] = useState(0);

  const doubled = useMemo(() => {
    return slowFunction(number);
  }, [number]);

  return (
    <>
      <h2>Doubled: {doubled}</h2>

      <button onClick={() => setNumber(number + 1)}>
        Change Number
      </button>

      <button onClick={() => setCount(count + 1)}>
        Re-render ({count})
      </button>
    </>
  );
}

ğŸ”¥ Result

Clicking Re-render â†’ âŒ slow function NOT called

Clicking Change Number â†’ âœ… slow function runs

ğŸ§  Think of useMemo as:

â€œOnly recalculate when necessaryâ€

ğŸ§  useCallback â€” Memoizing a FUNCTION
What it does

useCallback returns the same function reference between renders.

Syntax
const memoizedFn = useCallback(() => {
  doSomething();
}, [dependencies]);


âš ï¸ Functions are objects in JS â†’ new reference every render.

ğŸ”¬ Why function identity matters
() => {} !== () => {}


Even if logic is same â†’ reference is different

âœ… When to use useCallback

âœ” Passing functions to child components
âœ” With React.memo
âœ” Event handlers used frequently
âœ” Prevent unnecessary child re-renders

âŒ If function is not passed to child
âŒ If no performance issue

ğŸ§ª Example 2: Child re-render problem
âŒ Without useCallback
const Child = React.memo(({ onClick }) => {
  console.log("Child rendered");
  return <button onClick={onClick}>Child</button>;
});

function App() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    console.log("Clicked");
  };

  return (
    <>
      <Child onClick={handleClick} />
      <button onClick={() => setCount(count + 1)}>
        Parent ({count})
      </button>
    </>
  );
}


ğŸ”´ Child renders every time parent updates.

âœ… With useCallback
const handleClick = useCallback(() => {
  console.log("Clicked");
}, []);


ğŸŸ¢ Child renders only once

ğŸ§  Think of useCallback as:

â€œKeep the same function unless dependencies changeâ€

âš”ï¸ useMemo vs useCallback
Feature	useMemo	useCallback
Caches	Value	Function
Returns	Result	Function
Use case	Expensive computation	Stable function reference
Typical use	Filtering, sorting	Event handlers
Prevents	Recalculation	Re-render
ğŸ§© Important relationship
useCallback(fn, deps) === useMemo(() => fn, deps)


âš ï¸ But useCallback is clearer and recommended.

ğŸš¨ Dependency Array Rules (CRITICAL)
âŒ Wrong
useCallback(() => {
  console.log(count);
}, []);

âœ… Correct
useCallback(() => {
  console.log(count);
}, [count]);


If you miss dependencies â†’ stale data bug

ğŸ§  When NOT to use these hooks

Small apps

No performance issue

Simple components

Overusing causes:

harder code

more memory usage

ğŸ‘‰ Measure first, optimize second

ğŸ¯ Interview Gold Answers

Q: Why use useMemo?

To avoid expensive recalculations on every render.

Q: Why use useCallback?

To prevent unnecessary child re-renders by memoizing functions.

Q: Are they required?

No, theyâ€™re performance optimizations.

Q: Can we do API calls inside useMemo/useCallback?
âŒ No â€” side effects belong in useEffect.

ğŸ§ª Real-World Examples

Search filters

Product sorting

Dashboard analytics

Charts

Large lists

Memoized handlers in forms